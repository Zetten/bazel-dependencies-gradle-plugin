package com.github.zetten.bazeldeps

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonConfiguration
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.CacheableTask
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.TaskAction
import org.gradle.internal.hash.HashUtil
import reactor.core.publisher.Flux
import reactor.core.scheduler.Schedulers
import reactor.kotlin.core.publisher.toFlux
import java.io.File

@CacheableTask
open class GenerateRulesJvmExternal : DefaultTask() {

    @Input
    lateinit var dependencies: Set<ProjectDependency>

    @Input
    lateinit var repositories: List<String>

    @Input
    var createMavenInstallJson: Boolean = false

    @OutputFile
    lateinit var outputFile: File

    @OutputFile
    lateinit var mavenInstallJsonFile: File

    @TaskAction
    fun generateWorkspace() {
        logger.info("Generating Bazel rules_jvm_external attributes for {} dependencies", dependencies.size)

        val sortedRepositories = repositories.sorted()
        val sortedDependencies = dependencies.sorted()

        outputFile.writeText(
            """
            |load("@rules_jvm_external//:specs.bzl", "maven")
            |
            |REPOSITORIES = [
            |${sortedRepositories.joinToString("\n") { "    \"$it\"," }}
            |]
            |
            |ARTIFACTS = [
            |${sortedDependencies.joinToString("\n") { artifactBlock(it) }}
            |]
            |""".trimMargin()
        )

        if (createMavenInstallJson) {
            mavenInstallJsonFile.writeText(
                Json(JsonConfiguration.Stable.copy(prettyPrint = true)).stringify(
                    MavenInstallJson.serializer(),
                    MavenInstallJson(
                        dependencyTree = DependencyTree(
                            computeDependencyTree(sortedDependencies, sortedRepositories)
                        )
                    )
                )
            )
        }
    }

    private fun artifactBlock(dep: ProjectDependency): String {
        val params = mutableListOf("\"${dep.id.group}\"", "\"${dep.id.name}\"", "\"${dep.id.version}\"")
        if (dep.jar!!.extension != "jar") params += "packaging = \"${dep.jar.extension}\""
        if (dep.classifier != null) params += "classifier = \"${dep.classifier}\""
        if (dep.overrideLicenseTypes != null) params += "override_license_types = [${dep.overrideLicenseTypes.sorted().joinToString(
            ", "
        ) { "\"$it\"" }}]"
        if (dep.neverlink) params += "neverlink = True"
        if (dep.testonly) params += "testonly = True"

        return """
        |    maven.artifact(${params.joinToString(", ")}),
        """.trimMargin()
    }

}

@Serializable
data class MavenInstallJson(
    @SerialName("dependency_tree")
    val dependencyTree: DependencyTree
)

@Serializable
data class DependencyTree(
    @SerialName("conflict_resolution")
    val conflictResolution: Map<String, String> = emptyMap(),
    @SerialName("dependencies")
    val dependencies: List<DependencyTreeEntry>,
    @SerialName("version")
    val version: String = "0.1.0",
    @SerialName("__AUTOGENERATED_FILE_DO_NOT_MODIFY_THIS_FILE_MANUALLY")
    val dependencyTreeSignature: Int
) {
    constructor(dependencies: List<DependencyTreeEntry>) : this(
        dependencies = dependencies,
        dependencyTreeSignature = computeDependencyTreeSignature(dependencies)
    )
}

@Serializable
data class DependencyTreeEntry(
    @SerialName("coord")
    val coord: String,
    @SerialName("file")
    val file: String? = null,
    @SerialName("directDependencies")
    val directDependencies: List<String> = emptyList(),
    @SerialName("dependencies")
    val dependencies: List<String> = emptyList(),
    @SerialName("url")
    val url: String,
    @SerialName("mirror_urls")
    val mirrorUrls: List<String> = emptyList(),
    @SerialName("sha256")
    val sha256: String
)

private fun computeDependencyTree(
    dependencies: List<ProjectDependency>,
    repositories: List<String>
): List<DependencyTreeEntry> =
    dependencies.toFlux()
        .flatMap {
            if (it.srcJar != null) {
                Flux.just(
                    it, it.copy(
                        classifier = "sources",
                        jar = it.srcJar,
                        dependencies = it.dependencies.map { it.copy(classifier = "sources") }.toSet(),
                        allDependencies = it.allDependencies.map { it.copy(classifier = "sources") }.toSet()
                    )
                )
            } else {
                Flux.just(it)
            }
        }
        .parallel()
        .runOn(Schedulers.parallel())
        .map { dep ->
            val urls = dep.findArtifactUrls(repositories)
            DependencyTreeEntry(
                coord = dep.getJvmMavenImportExternalCoordinates(),
                directDependencies = dep.dependencies.map { it.getJvmMavenImportExternalCoordinates() }.sorted(),
                dependencies = dep.allDependencies.map { it.getJvmMavenImportExternalCoordinates() }.sorted(),
                url = urls.first(),
                mirrorUrls = urls,
                sha256 = HashUtil.sha256(dep.jar!!).asZeroPaddedHexString(64),
                file = "v1/${urls.first().replace("://", "/")}"
            )
        }
        .collectSortedList(compareBy { it.coord })
        .block()!!

// Implementation of https://github.com/bazelbuild/rules_jvm_external/blob/030ea9ef8e4ea491fed13de1771e225eb5a52d18/coursier.bzl#L120
private fun computeDependencyTreeSignature(dependencies: List<DependencyTreeEntry>): Int {
    val signatureInputs: List<String> = dependencies.map { dep ->
        var uniq = arrayOf(dep.coord)
        if (dep.file != null) {
            uniq += dep.sha256
            uniq += dep.file
            uniq += dep.url
        }
        if (dep.dependencies.isNotEmpty()) {
            uniq += dep.dependencies.joinToString(",")
        }
        uniq.joinToString(":")
    }
    val signatureString = "[${signatureInputs.joinToString(", ") { "\"$it\"" }}]"
    return signatureString.hashCode()
}
